\documentclass{ExcelAtFIT}
%\documentclass[czech]{ExcelAtFIT} % when writing in CZECH
%\documentclass[slovak]{ExcelAtFIT} % when writing in SLOVAK


%--------------------------------------------------------
%--------------------------------------------------------
%	REVIEW vs. FINAL VERSION
%--------------------------------------------------------

%   LEAVE this line commented out for the REVIEW VERSIONS
%   UNCOMMENT this line to get the FINAL VERSION
%\ExcelFinalCopy


%--------------------------------------------------------
%--------------------------------------------------------
%	PDF CUSTOMIZATION
%--------------------------------------------------------

\hypersetup{
pdftitle={Paper Title},
pdfauthor={Author},
pdfkeywords={Keyword1, Keyword2, Keyword3}
}

\lstset{
backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
basicstyle=\footnotesize\tt,        % the size of the fonts that are used for the code
}

%--------------------------------------------------------
%--------------------------------------------------------
%	ARTICLE INFORMATION
%--------------------------------------------------------

\ExcelYear{2019}

\PaperTitle{Distributed system for algorithmic trading}

\Authors{Michal Hornický}
\affiliation{*%
\href{mailto:xhorni14@fit.vutbr.cz}{xhorni14@fit.vutbr.cz},
\textit{Faculty of Information Technology, Brno University of Technology}}
%%%%--------------------------------------------------------
%%%% in case there are multiple authors, use the following fragment instead
%%%%--------------------------------------------------------
%\Authors{Jindřich Novák*, Janča Dvořáková**}
%\affiliation{*%
%  \href{mailto:xnovak00@stud.fit.vutbr.cz}{xnovak00@stud.fit.vutbr.cz},
%  \textit{Faculty of Information Technology, Brno University of Technology}}
%\affiliation{**%
%  \href{mailto:xdvora00@stud.fit.vutbr.cz}{xdvora00@stud.fit.vutbr.cz},
%  \textit{Faculty of Information Technology, Brno University of Technology}}

\Keywords{Automated trading --- Distributed systems --- Rust}

\Supplementary{\href{https://github.com/semtexzv/dp/}{Github Repository}}

\Abstract{
The success of cryptocurrencies like Bitcoin has created many new opportunities. One of them came somewhere around the year 2012-2013,
in a form of an online cryptocurrency exchange. Since then, many new online exchanges were created. These
exchanges provide unprecedented ease of use and access to everyone, contrasting existing financial exchanges.
Day-trading\footnote{Trading with short timeframes in order to capitalize on short-term price changes} on these exchanges is easy,
and has a large potential because of the extreme volatility of these new markets.
This paper outlines the design and implementation of a distributed system, that would facilitate this task.
The goals, which include ease of use for new users, scalability for large number of users, and customization for advanced users,
combined with problem domain pose interesting requirements, which influenced the design and implementation.
}

\Teaser{
\TeaserImage{price2.png}
}



%--------------------------------------------------------
%--------------------------------------------------------
%--------------------------------------------------------
%--------------------------------------------------------
\begin{document}

    \startdocument


    %--------------------------------------------------------
    %--------------------------------------------------------
    %	ARTICLE CONTENTS
    %--------------------------------------------------------

    %--------------------------------------------------------
    %--------------------------------------------------------
    %--------------------------------------------------------
    %--------------------------------------------------------
    \section{Introduction}

    \textbf{[Motivation]}
    The innovations in financial sector, mainly cryptocurrencies like Bitcoin, have created new opportunities. One of them,
    is the arrival of multiple online exchanges, that focus on trading cryptocurrencies. These exchanges have very low
    barrier to entry, and can be used for easy day trading. Goal of this project is creation of a website, that would allow
    automatization of day trading on these exchanges, and therefore would exploit the empty space in the market.

    \textbf{[Problem definition]} In order to allow effective day trading for multiple users, the system must be designed
    in a way that would allow seamless scalability. It also must provide simple interface that does not require advanced technical knowledge
    (Installation of local applications), and a way to express more complex strategies, to serve more advanced users.

    \textbf{[Existing solutions]} Most attempts to fail at one or more of the requirements outlined earlier. The older solutions
    are mostly command-line applications that require complicated installations, and hardware that must be continuously managed.
    Other cloud based solutions, that are more closely related to our approach are usually overly complex, requiring user to write
    complex strategies that must decide not only when to execute trades, but specifics of these trades.

    \textbf{[Our solution]} Our solution aims to improve on other ones in several aspects. The first is ease of use thanks to the fact, that the system
    is a web application that does not require manual installation onto a local machine. The second is extreme scalability
    of the implemented system through the use of a distributed architecture. The third is customization through
    use of LUA scripting language to implement trading strategies.

    \textbf{[Contributions]} Implemented system is built upon scalable architecture that utilizes cloud environment, is able to scale from single to thousands of users seamlessly,
    It also allows sub-second latency between receiving of new financial information and possible execution of actual trades on real exchange.
    Implemented system currently utilizes only one exchange, however support of additional exchanges should be extremely easy.

    \section{Theoretical background}
    In order to talk about automated trading , we must first outline, the idea of an exchange, as it is the environment, in which our system will operate.
    While historically, the exchanges dealt with physical goods, and were physical locations, almost all modern exchanges are purely virtual. The core concept of
    an exchange is the price discovery mechanism. This means, that the actual exchange doesn't determine price of an asset, but rather the price is "discovered"
    by interactions of individual actors on the exchange. In simplistic terms, this corresponds to supply-demand market mechanism. When the supply of an asset is larger
    than demand, the price falls, and when the demand rises, the price rises accordingly.

    \subsection{Automated trading}
    Today, most of the trading performed even on conventional exchanges is done by automated systems. Origins of these systems can be traced to the 1980s, but probably the
    biggest milestone was when IBM in 2001\cite{Tesauro:2001:HBA:501158.501183} experimented with automated trading, and implemented system consistently outperformed even professional traders.

    \subsection{High frequency trading}
    Modern incarnation of high-end automated trading systems is called High Frequency Trading(HFT). These systems are commonly co-located with the exchanges, aiming for lowest possible latency
    between receiving financial data, and execution of market orders. There are several key groups of these system , based on the decision process for creating market orders.

    We will focus on \textbf{Tick-data market making} strategies, that utilize periodic data about price of an asset, in order to determine short and long term trends of the price, and
    based on them, forecast the price into the future. These strategies do not rely on any other information sources.

    The benefit of this approach is mainly simplicity. The implemented strategies do not have to rely on complex data describing real world events, that might influence price
    of an asset(eg. company mergers), and implemented strategies do not have to perform actual trades explicitly. The strategy must only
    determine the desired market position (short or long), and the creation of the orders can be internally within the system.
    These kinds of strategies are also easily applied to multiple asset types simultaneously.

    \subsection{Computing environment}
    While strategies outlined earlier are easy to implement, they require non-trivial amount of computing power.
    Coupled with the the requirement to support multiple users, the requirements for computing power needed to
    run this system grow.

    In order to provide this amount of computing power, we decided to design and implement the system using distributed architecture.
    This means, that the system is written in manner, that allows its individual components to operate separately, and be deployed on different machines.
    To achieve this goal, we have chosen to use Cloud computing approach (\footnote{https://en.wikipedia.org/wiki/Cloud\_computing}) on the deployment side.
    And utilize Actor Model as the core paradigm on implementation side.

    \subsection{Actor model}
    Actor model is a conceptual model of describing concurrent computation. Each actor can: Create new actors, send messages, modify its state and decide how to respond to
    received messages. Primary constraint of this model is the restriction of modifying application state.
    Each actor can modify its local state however it wants, but can only affect other actors by sending messages.

    Thanks to this property of isolation, there are no necessary locks to ensure memory safety.
    It originated in 1973, and has been used for understanding distributed computation, and also as
    a basis of several implementations of concurrent systems.

    \subsection{Rust \& Actix}
    Thanks to authors previous experience with the Rust language, it was investigated as a possible implementation language for this project. Since
    the core computing parading chosen to implement this project is actor model, there were other languages that were also considered. Among them
    were C\# with Akka.NET, or Erlang, with it's distributed model, that is particularly suited for these kinds of applications. However, each of the
    alternatives was dismissed because of large run-time overhead (VM), or difficulty interacting with other required technologies.

    With the choice of rust as an implementation language, we have reduced the run-time overhead, and therefore also reduced the computing power requirements.

    Another aspect of the implementation stemming from the use of rust as an implementation language, is the use of Actix\footnote{https://actix.rs/} as a core
    architectural library. This library implements the Actor model, and each part of the system is built upon it.

    \section{Designed system}
    Probably the biggest obstacle to the implementation of the system was its distributed nature. On the implementation side, this meant the use of Actor model, as a
    core architectural paradigm. The use of the Actix library has simplified many challenges with the use of this computing paradigm, but it also
    came with some drawbacks. The library is written in a way that allows seamless use of actors within single or multi-threaded environments,
    each actor running concurrently, but it does not contain an implementation of primitives that would allow actors to communicate between processes
    or even different machines.

    \subsection{Communication}
    Therefore, part of this project was the design, and implementation of capability. We have designed and implemented the \textbf{actix-zmq} library, that
    provides actors for communication over the ZeroMQ networking technology, and \textbf{actix-comm} library that provides abstractions
    for implementing simple Request-Reply services, Publish-subscribe pipelines, and other supplementary components (eg. Load balancing broker for services).
    The \textbf{actix-comm} library builds on top of \textbf{actix-zmq}, and both of them should be usable in other projects, and will be published
    as separate libraries, that should enrich already rich ecosystem around the \textbf{Actix} library.

    \subsection{Deployment}
    Since we are using Cloud environment as our primary deployment target, this side of the system also had to be adapted.
    We decided to use \textbf{Kubernetes} as a primary tool for managing our deployments.

    Kubernetes is an orchestration tool, used for automated deployment and management of distributed systems running in the cloud environment.
    Kubernetes defines a set of primitives, which are used to describe a distributed system. The kubernetes
    runtime then dynamically modifies state of the system, to conform to described model. The kubernetes runtime
    runs on a Cluster. A cluster is comprised of multiple virtual machines(Nodes), and can dynamically scale number
    of used nodes.
%
%    Basic used primitives are:
%    \begin{itemize}
%        \item Namespace - Is a tool used to partition resources into disjoint sets.
%        \item Pod - A pod is a basic scheduling unit, it contains one or more docker containers, has assigned unique IP address
%        withing a cluster,and can define a storage volume, that it exposes to its containers.
%        \item Service - Is a set of homogeneous pods, that work together. Its main goal is to expose information about running
%        pods to internal DNS.
%        \item Deployment - Serves as a watchdog that automatically ensures there are pods in a healthy state available to
%        serve incoming requests8
%        \item Volume - Object representing a persistent storage.
%    \end{itemize}
%

    \subsection{Actual system}
    The actual system is then designed as a set of loosely coupled components. Each component is comprised of several kubernetes Pods,
    managed by a Deployment, and exposed by a service. Within each pod, there might be multiple containers, but most of them only use single one.

    Here are components that that describe our system in simplest terms
    \begin{itemize}
        \item Exchange - provides interface to a specific exchange,
        \item Core - Receives updates from exchange, Decides when to evaluate strategies against this data, also forward
        trading decisions to individual exchanges
        \item Eval - Evaluates strategies using multiple load-balanced workers
        \item Web - Provides web interface for user interaction
        \item Storage - Stores financial data, and user data.
    \end{itemize}


    \section{Implementation}
    As mentioned earlier, the implementation was performed using the Rust language on top of Actix actors as a basic architectural blocks.
    It is divided into 2 applications, The \verb|web| application houses the user interface implemented using actix-web as a back-end,
    and LitElement\footnote{https://lit-element.polymer-project.org/} based Single-Page application as front-end.

    The second application is the \verb|trader| application. This is implemented as a command line application, that houses several
    different components. Each component is started by specifying different command to this application. These individual components should
    be separated into different applications in the future.

    \subsection{Data flow}
    The whole system is best described by the type of data it consumes, and how this data flows throughout it. Primary data sources
    are individual exchanges, and the web application. The web application only communicates with the database, and thus is not that
    interesting in this aspect.

    However, the exchanges are more interesting. The exchanges each connect using \textbf{PUB} ZeroMQ socket to core service,
    that binds \textbf{SUB} socket to a known port. This forms a Fan-In topology, that would be difficult to implement using other technologies.

    The data flowing from exchanges is in the form of per minute OHLC\footnote{https://en.wikipedia.org/wiki/Open-high-low-close\_chart} data.
    This is then processed by the core component, which removes duplicate entries, determines when received data is final(there will be no more
    updates to data from a specific time interval), computes data points for different time-scales, and publishes them along with received updates.
    During this step, the data is also stored into persistent storage, which, for the momen, takes the form of a PostgreSQL database.

    This database, along with financial data, also stores user data. User data is primarily the strategies, assignment of these
    strategies to individual assets on an exchange, and information about trading accounts for an exchange. A strategy is a LUA\footnote{https://www.lua.org/} script, that takes OHLC data as an input, and produces
    desired market position as an output. Each strategy can be assigned to multiple assets.
    One asset, can only have assigned one strategy, and possibly one trading account.

    The decision component periodically loads the assignment information from the database, and for each update from the core
    component determines strategies, that should be evaluated, using newly updated data. It then submits a request to evaluation
    component, which performs the actual strategy execution. Evaluation component is implemented as a load-balancing broker, that distributes work to multiple workers in round-robin fashion.

    If an individual assignment had a trading account associated with it, the decision component then submits a request to \textbf{Position} component, along
    with the account information, which retrieves the state of an account from an exchange, and if necessary, submits trading orders, to
    move the balance int the desired market position.

    \section{Conclusions}
    \label{sec:Conclusions}

    \textbf{[Paper Summary]}
    This paper outlined the conceptual idea behind the project, the issues encountered and how they
    influenced the design and an actual implementation of the system. The system is implemented as a distributed application,
    with focus on scalability, and is accessible using a web application, satisfying the usability requirements.

    \textbf{[Highlights of Results]}
    The implemented system currently supports single exchange, and over 200 different asset pairs. Each of these
    asset pairs can have a single LUA strategy, and single trading account associated with it.
    The system supports executing large number of strategies, with sub-second latency between updates from an exchange, and
    execution of trades on these exchange. Compared to command-line application solutions, our system can support arbitrary number of
    strategies, with possible future improvement of tracking individual strategy performance. Compared to other cloud based solutions,
    our system provides extremely easy strategy implementations

    \textbf{[Paper Contributions]}
    Achievement of these goals was mainly possible due to distributed approach. However, this approach brought its own set of complications,
    which required solutions. These solutions were implemented in support libraries \verb|actix-zmq| and \verb|actix-comm|, that should
    be useful in other projects with similar goals.

    \textbf{[Future Work]}
    While functional, the system lacks several pieces of advanced functionality ( eg. More complex strategies or testing strategies on historical data).
    The system should be also extended, to support multiple exchanges. In addition to extending the actual system, the support libraries mentioned earlier
    are also good targets for future development.
    \section*{Acknowledgements}
    I would like to thank my supervisor RNDr. Marek Rychlý Ph.D. for his help, and valuable advice regarding this project provided during frequent meetings.

    \phantomsection
    \bibliographystyle{unsrt}
    \bibliography{2019-ExcelFIT-ShortName-bib}

\end{document}