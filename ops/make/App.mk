include ops/make/Macros.mk

$(call require,BUILD_TYPE)
$(call require,APP_NAME)
$(call require,DOCKER_REGISTRY_DOMAIN)
$(call require,DOCKER_REGISTRY_PATH)

# include dependencies generated by cargo
-include $(wildcard ./target/$(BUILD_TYPE)/*.d)
-include $(wildcard ./target/$(BUILD_TYPE)/deps/*.d)

SRC_DIR     := code/$(APP_NAME)
BINARY      := $(CWD)/target/$(BUILD_TYPE)/$(APP_NAME)
CODE_FILES  := $(wildcard $(SRC_DIR)/*) $(wildcard $(SRC_DIR)/**/*) $(wildcard code/deps/**/*)
DOCKERFILE  := ops/docker/Dockerfile # $(shell test -e $(SRC_DIR)/Dockerfile && echo "$(SRC_DIR)/Dockerfile" || echo "ops/docker/default.Dockerfile" )

DOCKER_IMAGE_VAR = $(shell echo "$(APP_NAME)_IMAGE" | tr '-' '_' | tr '[:lower:]' '[:upper:]')
DOCKER_MARK = target/docker/$(APP_NAME)

# We use binary hash as unique identifier of a release of an application
VERSION = $(shell sha256sum $(BINARY) | cut -c1-5 )

DOCKER_IMAGE_PACKAGE    = $(PROJECT_NAME)-$(APP_NAME)
DOCKER_IMAGE            = $(DOCKER_REGISTRY_PATH)/$(DOCKER_IMAGE_PACKAGE):$(VERSION)
DOCKER_IMAGE_DOMAIN     = $(DOCKER_REGISTRY_DOMAIN)/$(DOCKER_IMAGE)

.PHONY: build

build: $(BINARY)

$(BINARY) : $(CODE_FILES) Cargo.lock Cargo.toml
ifeq ($(BUILD_TYPE), release)
	cargo build --release --package $(APP_NAME)
else
	cargo build --package $(APP_NAME)
endif

.PHONY: image
image: $(DOCKER_MARK)

target/docker:
	mkdir -p ./target/docker

$(DOCKER_MARK): $(BINARY) $(DOCKERFILE) target/docker
	docker build --network "host" -f $(DOCKERFILE) -t $(DOCKER_IMAGE) \
	 --build-arg app_file=target/$(BUILD_TYPE)/$(APP_NAME) --build-arg src_dir=$(SRC_DIR) .
	docker push $(DOCKER_IMAGE)
	mkdir -p ./target/docker
	echo "$(DOCKER_IMAGE_VAR)='$(DOCKER_IMAGE)'" > ./target/docker/$(APP_NAME)
